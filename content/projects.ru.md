---
title: "Проекты"
draft: false
comments: false
showtoc: true
tocopen: true
---

## :bulb: Предложения в Open source
Я хочу быть полезным сообществу и предлагать свои улучшения для инструментов,
которыми пользуюсь сам :blush:.

### Kafka-python 

В одном проекте возникла необходимость избавиться от ребалансов консьюмеров Кафки, чтобы обеспечить 
постоянное чтение из топиков. Однако, ни одна из популярных клиентских библиотек (**kafka-python**, **confluent-kafka**, 
**pykafka**) не предлагала такой функциональности, несмотря на то, что она была реализована уже в 2.3.0 версии брокера. 
Сначала я реализовал эту фичу, доработав **KafkaConsumer** в репозитории проекта, а затем оформил всё 
[Pull request](https://github.com/dpkp/kafka-python/pull/2333)'ом. К сожалению, проект сейчас уже практически
заброшен.
  
***
  
### Django extensions 

При работе над большим количеством новых фич, я часто сталкивался с ситуацией, когда приходится переключаться
между ветками, откатывать миграции одной ветки и применять миграции другой. Пока вы работаете в одном Django app,
никаких проблем не возникает. Но когда миграции затрагивают несколько Django-приложений, откат каждого приложения 
становится неприятной рутиной.  
  
Я написал [Django-команду](https://github.com/django-extensions/django-extensions/pull/1676), 
которая фиксирует состояние миграций в текущей ветке в файл и позволяет легко переключаться между ветками.

***

### Jaeger client 
  
Jaeger - отличный инструмент для трассировки кода. Но однажды у меня возникла необходимость его более гибкой 
настройки, которую конфигурация клиентской библиотеки сделать не позволяла. Я предложил применить 
[внедрение зависимостей](https://github.com/jaegertracing/jaeger-client-python/issues/344) в класс конфигурации. 
***

## :open_file_folder: Мои проекты 

### [Relatives](https://relatives.tk) 

Сервис для построения фамильного древа.

Я давно хотел заняться фамильным древом, но не находил для этого подходящих свободных инструментов, а те, 
что были, не удовлетворяли моим требованиям. И я решил изобрести свой велосипед. А заодно использовать 
для этого какие-то современные технологии, чтобы лучше с ними разобраться. Поэтому выбор пал на **FastAPI** с 
асинхронным **ORM**, хотя не скрою, они здесь абсолютно неуместны, и тот же **Django** подошёл бы куда лучше.

`FastAPI` `Ormar` `Asyncio`
***

### Aiofutures

Библиотека для замены многопоточного executor'а асинхронным, опубликована в [PyPI](https://pypi.org/project/aiofutures/).
  
В одном из проектов я столкнулся с ограничениями всеми известного GIL из-за обширного HTTP взаимодействия в приложении.  
Таймауты на HTTP-запросы отрабатывают некорректно из-за большого количество потоков ОС и переключения контекста.  
Я принял решение вынести всё HTTP-взаимодействие в отдельный поток, который будет выполнять запросы асинхронно. Количество 
потоков в приложении сократилось с 24-25 до 10, таймауты стали работать корректно, потребление ресурсов значительно снизилось.
Тем самым была также заложена основа для переписывания приложения на асинхронный стиль. 
  
`Python` `asyncio`
***

### Dynamic-sitemap

Библиотека для генерации карты сайта, опубликована в [PyPI](https://pypi.org/project/dynamic-sitemap/), 
а документация размещена на [readthedocs](https://dynamic-sitemap.readthedocs.io/en/latest/#installation).
  
Изначально, мне требовалось только добавить sitemap в мой проект [блога на Flask](#блог-на-flask). Однако после того, как я не нашёл
более-менее привлекательной альтернативы, я решил написать свою библиотеку, а заодно научиться размещать их 
в python package index. Затем решил использовать её ещё и для изучения различных инструментов, 
например, [Sphinx](https://www.sphinx-doc.org/en/master/).   
  
`Python` `Sphinx`
***
